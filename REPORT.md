# Отчет по курсовому проекту
## по курсу "Логическое программирование"

### студент: Пермяков Н.А.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |



## Введение

В результате выполнения курсового проекта будут получены и применены навыки логического и функционального программирования при решении реалистичной задачи. Курсовой проект содержит построенное и проанализированное родословное дерево Кеннеди, 35-го президента США с семью поколениями.

## Задание

 1. Создать родословное дерево своего рода на несколько поколений (3-4) назад в стандартном формате GEDCOM с использованием сервиса MyHeritage.com 
 2. Преобразовать файл в формате GEDCOM в набор утверждений на языке Prolog, используя следующее представление: parents(потомок, отец, мать).
 3. Реализовать предикат проверки/поиска шурина 
 4. Реализовать программу на языке Prolog, которая позволит определять степень родства двух произвольных индивидуумов в дереве
 5. [На оценки хорошо и отлично] Реализовать естественно-языковый интерфейс к системе, позволяющий задавать вопросы относительно степеней родства, и получать осмысленные ответы. 

## Получение родословного дерева

С помощью программы "My Family Tree" и открытых источников данных было составленно неполное родословное дерево глубиной в 7 поколений. Генеалогическое древо покрывает временной промежуток с 1984г. по 1858г. (крайние известные даты рождения).  
Ссылка на ресурс: https://www.microsoft.com/ru-ru/p/my-family-tree/9nblggh2k2xc

## Конвертация родословного дерева

Для преобразования файла в словарь утверждений использовался Python 3.6. Для реализации предиката проверки и поиска с целью определения степени родства двух произвольных индивидуумов в дереве использовался Prolog.

> Декоратор открытия - закрытия файла

    def  open_close_file(*name_args, **name_kwargs):
	    if  len(name_kwargs) > 0:
		    if  'fin'  in name_kwargs.keys() and  'fout'  in name_kwargs.keys():
			    fin = name_kwargs['fin']
			    fout = name_kwargs['fout']
		    elif  'fin'  in name_kwargs.keys():
			    fin = name_kwargs['fin']
			    fout = None
		    else:
			    print("invalid args of decorator")
	    else:
		    print("invalid args of decorator")
	    def  decorator(func):
		    def  _file(*args, **kwargs):
			    with  open(fin[0], fin[1], encoding='utf8', errors='ignore') as f_input:
				    if fout == None:
					    file_lines = f_input.readlines()
					    done = func(file_lines, *args, **kwargs)
					else:
						with  open(fout[0], fout[1]) as f_prolog:
						    file_lines = f_input.readlines()
						    done = func(file_lines, f_prolog, *args, **kwargs)
					    f_prolog.close()
				    f_input.close()
			    return done
		    return _file
    return decorator

	Декоратор нужен для безопасной работы с файлом, при выходе из исполняемой функции "func" оба файла закрываются в контекстном менеджере, что позволяет избежать утечек памяти. Аргументы "func" передаются в переменных "*args" "**kwargs" с последующей распаковкой.

## Предикат поиска родственника

Приведенный ниже фрагмент генератора необходим для  поиска родственника в заданным пользователем временном окне.
На вход функции передается список строк файла, по которым в цикле прверяем на совпадения условий фильтра и одной из колонок файла. Как только находим крайнюю дату - запускается еще один цикл для сбора ранних строк и последующих, относящихся к крайней дате. Затем это повторяется до следующей границы временного промежутка. Собранная информация по одному человеку передается на выход генератору. Осуществляются "ленивые запросы".

    if  len(year) > 2  and  int(year) >= old_year \
        and  int(year) < near_year:
	    select_chan = []
	    tmp_lines = []
	    c += 1
	    for j, tmp_line in  enumerate(file_lines):
		    if j >= i - 10  and j < i:
			    tmp_lines.update(tmp_line.replace('//', '').replace('/-/', '').strip())
		    elif j == i:
			    tmp_lines.update(tmp_line.replace('//', '').replace('/-/', '').strip())
			    if j > 10:
				    k = 10
			    else:
				    k = j
				    while k >= 0  and tmp_line.split(' ', 2)[0] != '0':
					    select_chan.update(tmp_lines[k].replace('//', '').replace('/-/', '').strip())
					    k -= 1
			elif j > i:
				if tmp_line.split(' ', 2)[0] != '0'  and j <= i + 10:
					select_chan.update(tmp_line.replace('//', '').replace('/-/', '').strip())
				else:
					yield select_chan
				break

## Определение степени родства

## Естественно-языковый интерфейс

## Выводы

В процессе выполнения курсового проекта были получены и применены навыки логического и функционального программирования. Использовались декораторы и лямбда выражения для получения информации из файла и регулярные выражения для очистки данных. Курсовой проект содержит построенное и проанализированное родословное дерево. 

